# Ch18. 함수형 관점으로 생각하기

지금까지 **함수형**이란 말을 많이 언급했는데, 그래서 함수형을 적용하면 어떤 점이 좋을것인지 알아보자.



# 1. 시스템 구현과 유지보수

누군가 우리에게 이미 구현되어 있지만 경험해본 적 없는 대규모 소프트웨서 시트메 업그레이드 관리를 요청한다면 받아들여야 할까?

지금까지는 자바8의 스트림을 이용하면 **locking**문제를 신경쓰지 않을 수 있었다.

단, 자바 8의 스트림을 이용하려면 상태가 없는 동작 이어야 한다는 조건을 만족해야 한다.

또한 쉽게 유지보수할 수 있으려면 프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영한다면 좋을 것이다.

시스템의 각 부분의 상호 의존성을 가리키는 결합성과 시스템의 다양한 부분이 서로 어떤 관계를 갖는지 가리키는 **응집성**이라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.



그러나 유지보수 중 코드 크래시 디버깅 문제를 많이 겪는다. 이는 예상치 못한 변숫값 때문에 발생할 수 있다.

여기서 함수형 프로그래밍이 제공하는 **부작용 없음**과 **불변성**이라는 개념이 이 문제를 해결하는 데 도움을 준다.



## - 공유된 가변 데이터

변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.

어떤 변수를 참조하는 여러 클래스가 존재하는 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.



어떠한 자료구조도 바꾸지 않는 시스템이 있다고 가정해보면, 자료구조의 값이 바뀔 일이 없으니 유지보수하기가 쉬울 것이다.

자신을 포함하는 클래스의 상태와 다른 객체의 상태를 바꾸지 않고, 오직 `return`문을 통해서만 자신의 결과를 반환하는 메서드를 **순수** 메서드 또는 **부작용 없는** 메서드라고 한다.

>   *부작용*
>
>   -   자료구조를 고치거나 필드게 값을 할당(`setter` 같은 생성자 이외의 초기화 동작)
>   -   예외 발생
>   -   I/O 동작

불변객체를 이용해서 부작용을 없애는 방법도 있다. 불변객체는 복사하지 않고 공유할 수 있으며 객체의 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.



## - 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다.

-   명령형
    -   '이 일을 먼저하고, 그 다음에 저 값을 갱신하고, 그 다음에 ...'
    -   처럼 **어떻게** 수행할 것인지에 집중하는 방식
-   선언형
    -   스트림의 내부반복
    -   처럼 **무엇을** 에 집중하는 방식



## - 왜 함수형 프로그래밍인가?

함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용이 없는 계산을 지향한다.

선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.

지금까지 보여준 람다표현식이나 스트림 등의 기능은 함수형 프로그래밍의 특징을 고스란히 보여준다.



# 2. 함수형 프로그래밍이란 무엇인가?

*함수란 무엇인가?*

`int` 와 `double`을 받아서 `double`를 반환하는 메서드가 있다고 생각하자. 이 메서드는 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 가지고 있다.

함수형 프로그래밍에서 **함수** 수학정인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 **부작용이 없어야 한다.**



결과적으로

-   **함수 그리고 `if-then-else` 등의 수학적 표현만 사용하는 방식**을 순수 함수형 프로그래밍
-   **시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로 함수형이 아닌 기능도 사용하는 방식**을 함수형 프로그래밍

이라고 한다.



## - 함수형 자바

실질적으로 자바는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다.

하지만 시스템의 컴포너느가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수는 있다.

자바에서는 순수 함수형이 아니라 **함수형 프로그램**을 구현할 것이다. 실제 부작요이 있지만 아무도 이를 보지 못하게 함으로써 **함수형**을 달성할 수 있다.



단일 스레드로 실행되는 프로그램의 입장에서는 어떤 메서드가 아무 부작용을 일으키지 않으므로 함수형 메서드라 간주할 수 있지만

다른 스레드가 해당 스레드의 필드의 값을 확인한다든가 아니면 메서드를 호출하는 상황이 발생한다면 이 메서드는 함수형이 아니다.

메서드의 바디를 잠금(`lock`)하여 이 문제를 해결할 수는 있지만 멀티코어 프로세서의 두 코어를 활용해서 메서드를 병렬로 호출할 수 없게 된다.
(프로그램 입장에서는 부작용이 사라졌지만 프로그래머 관점에서는 프로그램의 실행 속도가 느려졌다!)



***그래서 함수형이뭐고 어떻게 쓰는가?***

-   **함수나 메서드는 지역변수만을 변경해야 `함수형`이라고 할 수 있다.**

-   그리고 함수나 메서드에서 참족하는 객체가 있다면 그 객체는 **불변객체**여야 한다.

    -   즉 객체의 모든 필드가 `final`이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.

-   함수나 메서드가 어떤 예외도 일으키지 않아야 한다.

    -   예외가 발생하게 되면 `return`으로 결과를 반환할 수 없게 될 수 있기 때문이다.

        >   예외를 사용하지 않고 함수를 표현하려면 어떻게 해야 할까?
        >
        >   바로 **Optional** 을 사용하면 문제를 해결할 수 있다.
        >
        >   즉, 호출자는 메서드 호출 결과로 빈 Optional이 반환되는지 확인해야 한다.
        >
        >   이는 상당히 귀찮은 작업처럼 보이지만 모든 코드에 Optional을 사용해야 하는 것은 아니다.

-   함수형에서는 비함수형 동작을 감출 수 있는 상황에서만, 부작용을 포함하는 라이브러리 함수를 사용해야한다.
    (자료구조를 복사한다던가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 얼 수 없도록 감춰야 한다.)



## - 참조 투명성

`부작용을 감춰야 한다`라는 제약은 **참조 투명성** 개념으로 귀결된다.

즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.

예를 들어 `"seoul"`.replace(`'s'`, `'S'`) 이라는 코드는 항상 같은 결과가 나오므로 `String.replace`는 참조적으로 투명하다.

다시말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.

>   `Random.nextInt`라던가, `Scanner.~` 라던가 이런 메서드는 함수형이 될 수 없다.



이러한 참조 투명성은 프로그램을 이해하는데 큰 도움을 준다.

또한, 비싸거나 오랜 시간이 걸리는 연산을 **기억화** 또는 **캐싱**해서 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.



# 3. 재귀와 반복

순수 함수형 프로그래밍 언어에서는 `while, for` 과 같은 반복문을 포함하지 않는다. 왜 그럴까?

이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다.



while루프의 조건문을 갱신해야 할 때가 있다. 그렇지 않으면 루프가 아예 실행되지 않거나 무한반복될 수 있끼 때문이다.

일반적인 상황에서는 루프를 안전하게 사용할 수 있다. 함수형 스타일에서는 다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없다고 했다.

즉, 지역변수는 자유롭게 갱신할 수 있는 것이다.

다음은 자바의 `Iterator`로 `for(Apple a : apples){}`라는 `for-each` 루프를 표현한 코드다.

```java
Iterator<Apple> it = apples.iterator();
while (it.hasNext()) {
    Apple apple = it.next();
    // ...
}
```

위 코드에서 호출자는 변화를 확인할 수 없으므로 아무 문제가 없다.
(next로 Iterator의 상태를 변환했고, while 바디 내부에서 apple 변수에 할당하는 동작을 할 수 있다.)



하지만 다음과 같은 `for-each`루프를 사용하는 검색 알고리즘은 문제가 될 수 있다.

```java
public void searchForGold(List<String> l, Stats stats) {
    for (String s : l) {
        if ("gold".equals(s)) {
            stats.incrementFor("gold");
        }
    }
}
```

루프의 바디에서 항수형과 상충하는 부작용이 발생한다.

루프 내부에서 프로그램의 다른 부분과 공유되는 `stats` 객체의 상태를 변화시킨다.

그럼 어떻게 프로그램을 구현해야 할까? -> 이론적으로 재귀를 이용하면 루프마다 갱신되는 반복 변수를 제거할 수 있다.

```java
// 반복 형식의 팩토리얼 함수
static int factorialIterative(int n) {
    int r = 1;
    for (int i = 1; i <= n; i++) {
        r += i;
    }
    return r;
}
// -> 일반적인 루프를 사용한 코드로 매 반복마다 변수 r과 i가 갱신

// 재귀 형식의 팩토리얼 함수
static long factorialRecursive(long n) {
    return n == 1 ? : 1 : n * factorialRecursive(n - 1);
}
// -> 자기 자신을 호출하는 방식으로 좀 더 수학적인 형식

// 스트림 형식의 팩토리얼
static long factorialStream(long n) {
    return LongStream.rangeClosed(1, n)
        			 .reduce(1, (long a, long b) -> a * b);
}
```



일반적으로 반복코드보다 재귀코드가 더 비싸다.

함수를 호출할 때마다 호출 스택에 각 호출 시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어진다.

즉, 재귀 팩토리얼의 입력값에 비례해서 메모리 사용량이 증가한다. 따라서 큰 입력값을 사용하면 `StackOverflowError`가 발생한다.



그렇다면 재귀는 쓸모없는것인가?

함수형 언어에서는 **꼬리 호출 최적화**라는 해결책을 제공한다.

```java
// 꼬리 재귀 팩토리얼
static long factorialTailRecursive(long n) {
    return factorialHelper(1, n);
}
static long factorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n, n - 1);
}
```

`factorialHelper` 에서 재귀 호출이 가장 마지막에서 이루어지므로 꼬리재귀이다.

중간결과를 각각의 스택프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다.



**결론적으로 자바8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다.**

또한 반복을 재귀로 바꾸면 더 간결하고, 부작용이 없는 알고리즘을 만들 수 있고 좀 더 쉽게 읽고/쓰고/이해할 수 있는 예제를 만들 수 있다.