# Ch21. 자바의 미래

# 자바8의 기능 리뷰

---

자바8에 추가된 대부분의 새로운 기능은 자바에서 함수형 프로그래밍을 쉽게 적용할 수 있도록 도와준다.

자바8에 이러한 변화가 생긴 이유는 커다란 두 가지 추세 때문이다.

-   멀티코어 프로세서의 파워를 충분히 활용해야 한다는 것이다.
    -   무어의 법칙에 따라 실리콘 기술이 발전하면서 개별 CPU 코어의 속도가 빨라지고 있다.
    -   즉, 코드를 병렬로 실행해야 더 빠르게 코드를 실행할 수 있는 것이다.
-   간결하게 데이터 컬렉션을 다루는 추세이다.
    -   간결하게 데이터 컬렉션을 처리하려면 불변값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요하다.



필드를 변화하고 반복자를 적용하는 기존의 객체지향, 명령형 언어로는 이러한 추세를 만족시키기 어렵다.

한 코어에서 데이터를 변화시키고 다른 코어에서 이 데이터를 읽으려면 비싼 비용을 치러야할 뿐 아니라 lock 관련 버그도 많이 밸상한다.

하지만 함수형 프로그래밍을 사용하면 이 두가지 추세를 모드 사용할 수 있다.



## 1. 동작 파라미터화(람다와 메서드 참조)

재사용할 수 있는 `filter` 같은 메서드를 구현하려면 `filter` 메서드의 인수가 필터링 조건을 받도록 만들어야 한다.

기존의 자바로도 이런 기능을 구현할 수 있지만 상당히 복잡한 코드를 구현해야 하며 유지보수하는 것도 쉽지 않다.



함수형 프로그래밍에서 지원하는 메서드로 코드 블록을 전달하는 기법을 자바8에서 제공한다.

-   `apple -> apple.getWeight() > 150` 같은 람다 코드를 전달할 수 있다.
-   `Apple::isHeavy` 같은 기존 메서드의 메서드 참조를 전달할 수 있다.



## 2. 스트림

자바의 컬렉션 클래스, 반복자, `for-each` 같은 구문은 오랫동안 사용된 기능이지만 자바8 설게자는 완전한 새로운 스트림 API를 만들었다.

컬렉션에 어떤 문제가 있었을까?

컬렉션에 세 가지 연산을 적용한다고 가정할 때 컬렉션의 필드를 더할 수 있는 객체를 매핑하고, 조건을 만족하는 합계를 필터링한 다음에 결과를 정렬해야한다.

따라서 컬렉션을 각각 세 번 탐색해야 한다.

반면 스트림 API는 이들 연산을 **파이프라인 이라는 게으른 형식의 연산**으로 구성한다.

그리고 **한 번의 탐색으로 파이프라인의 모든 연산을 수행한다.**

따라서 큰 데이터 집합일수록 스트림의 데이터 처리 방식이 효율적이며 메모리 캐시 등의 관점에서도 커다란 데이터 집합일수록 탐색 횟수를 최소화하는 것이 아주 중요하다.



또한, 멀티코어 CPU를 활용해서 병렬로 요소를 처리하는 기능도 매우 중요한 점이다. 스트림의 `parallel` 메서드는 스트림을 병렬로 처리하도록 지정하는 역할을 한다.



## 3. CompletableFuture 클래스

자바 5부터 `Future` 인터페이스를 제공한다. `Future`를 이용하면 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어로 작업을 할당할 수 있다.

즉, 멀티코어를 잘 활용할 수 있다. 다른 작업을 생성한 기존 작업에서 결과가 필요할 때는 `get` 메서드를 호출해서 생성된 `Future`가 완료될 때까지 기다릴 수 있다.

-   스트림에서는 파이프라인 연산을 구성할 수 있으므로 `map`, `filter` 등으로 동작 파라미터화를 제공한다. 따라서 반복자를 사용했을 때 생기는 불필요한 코드를 피할 수 있다.
-   마찬가지로 CompletableFuture는 `Future`와 관련한 공통 디자인 패턴을 함수형 프로그래밍으로 간결하게 표현할 수 있도록 메서드를 제공한다. 따라서 명령형에서 발생하는 불필요한 코드를 피할 수 있다.



## 4. Optional 클래스

자바 8 라이브러리는 `T` 형식의 값을 반환하거나 아니면 값이 없음을 의미하는 `Optional.empty`라는 정적메서드를 반환할 수 있는 **Optional<T> **클래스를 제공한다.

Optional은 프로그램을 쉽게 이해하고 문서화하는데 큰 도움을 주며 에러가 잘 발생할 수 있는 계산을 수행하면서 값이 없을 때 에러를 발생할 수 있는 null대신 **정해진 데이터 형식을 제공**할 수 있다.

일관적으로 Optional을 사용한다면 `NPE`가 발생하지 않을 것이다.

스트림 클래스가 제공하는 것과 비슷한 동작으로 계산을 연결할 때 함수형을 사용할 수 있으며 값이 없는 상황을 **사용자 코드에서 확인하는 것이 아니라 라이브러리에서 확인할 수 있다.**

또 자바9에서는 Optional API에 `stream(), or(), ifPresentOrElse()` 등의 새로운 메서드를 추가했다.



## 5. Flow API

Flow API는 호환성을 높일 수 있도록 라이브러리가 구현할 수 있는 네 개의 인터페이스

`Publisher, Subscriber, Subscription, Processor`를 포함한다.



## 6. 디폴트 메서드

`default method`를 인터페이스에 추가할 수 있게 되면서 메서드의 기본 구현을 제공할 수 있게 된다.

인터페이스에 새로운 기능을 추가했을 때 기존의 모든 구현클래스가 새로 추가된 기능을 구현하지 않을 수 있게 되었다는 점에서 디폴트메서드는 아주 훌륭한 도구이다.

이 덕분에 인터페이스가 바뀌어도 사용자는 신경쓸 필요가 없게된다.



# 자바9 모듈 시스템

---

자바9에서는 새 언어기능은 추가되지 않았지만

스트림의 `takeWhile`, `dropWhile` 그리고 `CompletableFuture`의 `completeOnTimeout` 등 자바 8에서 시작된 여러 기능을 강화했다.

자바9의 핵심은 **새 모듈 시스템**이다. 여기엔 **module-info.java**파일이 추가되었지만 언어적으로는 바뀐 것이 없다.

하지만 모듈시스템 덕분에 아키텍처 관점에서 애플리케이션을 설계하고 구현하는 방식이 바뀌었고 하위 부분간의 경계와  상호작용 방법 정의가 명확해졌다.



새로운 자바 모듈 시스템 덕분에 자바 런타임이 작은 부분으로 나눠질 수 있게 되었으므로 애플리케이션에서는 필요한 부분만 사용할 수 있다.

예를들어 CORBA가 새 자바 프로젝트에 필요하다면 필요한 기능만 추가하면 된다.

즉 자바 모듈 시스템 덕분에 사물인터넷 애플리케이션이나 클라우드에서 자바 런타임을 사용할 수 있기 때문이다.

>   자바 모듈 시스템의 장점
>
>   -   **안정적 설정**
>       -   모듈 요구사항을 명시적으로 선언함으로 의존성 빠짐, 충돌, 순환 등의 문제를 런타임이 아니라 빌드 과정에서 일찍 확인할 수 있다.
>   -   **강한 캡슐화**
>       -   자바 모듈 시스템은 특정 패키지만 노출한 다음 각 모듈에서 공개할 부분과 내부 구현의 영역 접근을 분리할 수 있다.
>   -   **보안성 개선**
>       -   사용자가 모듈의 특정 부분을 사용할 수 없도록 함으로 해커가 보안제어를 뚫기가 어려워졌다.
>   -   **성능 개선**
>       -   클래스가 런타임이 로드된 다른 클래스를 참조하는 상황보다는 적은 수의 컴포넌트를 참조할 때 최적화 기술이 더 효과를 발휘한다
>   -   **확장성**
>       -   자바 모듈 시스템은 자바 SE 플랫폼을 작은 부분으로 나눔으로 실행중인 애플리케이션에서 필요한 부분만 사용할 수 있다.



## 자바10 지역 변수형 추론

자바에서는 기본적으로 변수가 메서드를 정의할 때 다음 예제처럼 형식을 지정해야 한다.

```java
double convertUSDToGBP(double money) { ExchangeRate e ... }
```

위 예제는 convertUSDToGBP의 결과, 인수 money, 지역 변수 e라는 세 가지 형식이 사용되었다.

그러나 시간이 지나면서 이와 같은 엄격한 형식 지정이 조금 느슨해졌다.

우선, 컨텍스트로 형식을 유추할 수 있는 상황에서는 제네릭의 형식 파라미터를 생략할 수 있다.

```java
Map<String, List<String>> myMap = new HashMap<String, List<String>>();
// 자바7 부터는 위 코드를 아래처럼 간소화할 수 있다.
Map<String, List<String>> myMap = new HashMap<>();
```



마찬가지로 컨텍스트로 형식을 유추할 수 있는 다음과 같은 람다 표현식이 있다고 가정하자.

```java
Function<Integer, Boolean> p = (Integer x) -> booleanExpression;
// 위 코드를 다음처럼 줄일 수 있다.
Function<Integer, Boolean> p = x -> booleanExpression;
```

이렇게 형식이 생략되면 컴파일러가 생략된 형식을 추론(infer)한다.



이렇게 한 개의 식별자로 구성된 형식에 형식 추론을 사용하면 다양한 장점이 생긴다.

-   한 형식을 다른 형식으로 교체할 때 편집 작업이 줄어든다.
-   하지만 형식의 크기가 커지면서 제네릭이 다른 제네릭 형식에 의해 파라미터화될 수 있는데 형식 추론으로 가독성이 좋아질 수 있다.

>   형식 추론은 명확하게 이루어져야 한다.
>
>   형식을 추론하는 방법이 하나뿐이거나, 하나로 쉽게 문서화할 수 있거나, 사용자가 생략한 형식을 다시 만들 수 있는 상황에서 빛을 발한다.
>
>   하지만 사용자가 의도했던 형식과 다른 형식을 추론하기 시작하면 문제가 발상한다.
>
>   따라서 **두 가지 이상의 형식으로 추론할 수 있는 상황에서는 임의로 형식을 추론하여 문제를 일으킬 수 있는 여지를 남겨두는 것보다는 에러를 발생시키는 것이 바람직하다.**



스칼라와 C#언어에서는 지역 변수의 형식을 `var`키워드로 대체할 수 있는데 그러면 컴파일러가 변수 할당문의 오른쪽 내용을 기초로 형식을 추론한다.

```c#
var map = new HashMap<String, List<String>>();
```

이를 **지역 변수형 추론** 이라 부르며 자바10에 추가된 기능이다.

하지만 `Vehicle`을 상속하는 `Car`가 있을 때 `var x = new Car()` 로 정의한다면 x의 형식은 `Car`일까 `Vehicle`일까?

상식적으로 변수의 형식은 초기화의 형식과 같다고 간주할 수 있기 때문에 초기화 코드가 없을 때는 var를 사용할 수 없다는 제약이 있다.



# 자바의 미래

---

이 절에서 살펴보는 내용은 JDK 개선 제안 중 좋은 제안임에도 불구하고 기존 기능과의 상호 작용이나 기타 문제 때문에 자바에 채택되지 못한 이유를 설명한다.



# 더 빠르게 발전하는 자바

---

자바 아키텍트가 평균적으로 2년이 넘어야 주요 업데이트가 릴리즈 되는데 이런 정책으로는 빠르게 언어가 진화할 수 없으므로 더 이상 유지할 수 없음을 깨닫고 이제부터 자바는 6개월 개발 주기를 갖기로 결정했다.

즉, 자바와 JVM의 주요 릴리즈는 2018년 3월 자바10이 릴리즈됨을 기점으로 2018년 9월에는 자바 11의 릴리즈가 예정되었다.

이런 빠른 개발주기가 언어 자체에도 이로울 뿐 아니라 새로운 기술을 끊임없이 시험하는 빠르게 변화하는 회사와 개발자에게도 도움이 된다는 사실을 깨달았다.



모든 소프트웨어 시스템과 언어가 빨리 개선되어야 하는 요즘 상황에서 자바가 더 짧은 개발 주기를 갖게 되는 것은 바람직한 현상이다.

짧은 개발 주기 덕분에 자바는 적당한 속도로 진화할 수 있으며 앞으로도 개발에 유용하고 적절한 언어가 될 수 있을 것이다.

# 결론

자바8은 자바 역사를 통틀어 가장 큰 변화가 일어났던 버전이다.

자바8과 비교할만한 릴리즈를 두개 꼽자면 2005년에 제네릭이 추가되었던 자바 5 버전이다.

자바9의 주요 기능인 모듈 시스템은 개발자보다는 소프트웨어 아키텍트가 더 많은 관심을 가질 것으로 보인다.

자바10에서는 이미 다른 언어에서 생산성을 높이도록 지원하기 시작한 지역변수형 추론 기능을 도입했다.

자바11에서는 암묵적 형식의 람다 표현식의 파라미톡에 지역변수형 문법을 사용할 수 있도록 지원한다. 또, 새로운 비동기 HTTP 클라이언트를 제공할 것이라는 것이 중요하다.

자바12는 함수형 프로그래밍 언어의 핵심 기능으로 `switch` 구문에 구분 대신 표현식을 사용할 수 있도록 허용할 것이다.

